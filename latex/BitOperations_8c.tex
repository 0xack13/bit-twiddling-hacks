\hypertarget{BitOperations_8c}{}\section{source/src/\+Bit\+Operations.c File Reference}
\label{BitOperations_8c}\index{source/src/\+Bit\+Operations.\+c@{source/src/\+Bit\+Operations.\+c}}


Several bit operations and manipulations, also known as \textquotesingle{}bit hacks\textquotesingle{}.  


{\ttfamily \#include \char`\"{}Bit\+Operations.\+h\char`\"{}}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
uint64\+\_\+t \hyperlink{BitOperations_8c_a82ec79150db7a149f761dba0c00341ad}{bit\+Getm} (uint64\+\_\+t \+\_\+var, uint64\+\_\+t \+\_\+mask)
\begin{DoxyCompactList}\small\item\em Get the value of a bit or bits according to a mask. \end{DoxyCompactList}\item 
bool \hyperlink{BitOperations_8c_aceacd30a5f69a402340dce032e9a7ca2}{bit\+Get} (uint64\+\_\+t \+\_\+var, uint8\+\_\+t \+\_\+n)
\begin{DoxyCompactList}\small\item\em Get the value of a single bit. \end{DoxyCompactList}\item 
bool \hyperlink{BitOperations_8c_a8498303fa2475f5c04212f1269ca2e38}{is\+Positive} (int32\+\_\+t const \+\_\+var)
\begin{DoxyCompactList}\small\item\em Compute the sign of an integer. \end{DoxyCompactList}\item 
bool \hyperlink{BitOperations_8c_ab610bca7d4f1b073611fd55ed5ab074a}{is\+Odd} (int64\+\_\+t const \+\_\+var)
\begin{DoxyCompactList}\small\item\em Compute parity of a variable to see if it is odd. \end{DoxyCompactList}\item 
bool \hyperlink{BitOperations_8c_a0a9fd2264e67c57264360215712e8131}{is\+Even} (int64\+\_\+t const \+\_\+var)
\begin{DoxyCompactList}\small\item\em Compute parity of a variable to see if it is even. \end{DoxyCompactList}\item 
bool \hyperlink{BitOperations_8c_a5a16a55c4150b94d46a15bb4bdb16ab8}{have\+Opposite\+Signs} (int32\+\_\+t const \+\_\+x, int32\+\_\+t const \+\_\+y)
\begin{DoxyCompactList}\small\item\em Detect if two integers have opposite signs. \end{DoxyCompactList}\item 
int32\+\_\+t \hyperlink{BitOperations_8c_a2a80e0c1b11281eedafad0691563e986}{min} (int32\+\_\+t const \+\_\+x, int32\+\_\+t const \+\_\+y)
\begin{DoxyCompactList}\small\item\em Compute the minimum of two integers without branching. \end{DoxyCompactList}\item 
int32\+\_\+t \hyperlink{BitOperations_8c_a98b24b67752cb7a65d0bf14efd403a72}{max} (int32\+\_\+t const \+\_\+x, int32\+\_\+t const \+\_\+y)
\begin{DoxyCompactList}\small\item\em Compute the maximum of two integers without branching. \end{DoxyCompactList}\item 
bool \hyperlink{BitOperations_8c_ac5c1620193273b5d6bc97d18b5b94a33}{is\+Power\+Of2} (uint64\+\_\+t const \+\_\+var)
\begin{DoxyCompactList}\small\item\em Determining if an integer is a power of 2. \end{DoxyCompactList}\item 
void \hyperlink{BitOperations_8c_a6c611cfb3747d5d8adb868840060c1bc}{modify\+Bits} (uint32\+\_\+t $\ast$const \+\_\+var, uint32\+\_\+t const \+\_\+mask, bool const \+\_\+f)
\begin{DoxyCompactList}\small\item\em Conditionally set or clear bits without branching. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{BitOperations_8c_ac10caf47473a5d1c6b3cfd6808d61d9e}{merge\+Bits} (uint32\+\_\+t const \+\_\+x, uint32\+\_\+t const \+\_\+y, uint32\+\_\+t const \+\_\+mask)
\begin{DoxyCompactList}\small\item\em Merge bits from two values according to a mask. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{BitOperations_8c_a6c1510fc2d41e804ab05585b66cc59cd}{n\+Bits\+Set} (uint32\+\_\+t const \+\_\+var)
\begin{DoxyCompactList}\small\item\em Counting bits set. \end{DoxyCompactList}\item 
bool \hyperlink{BitOperations_8c_afbf3c541fcc9a3a38f94df4c91ccf320}{is\+Odd\+Parity} (uint64\+\_\+t const \+\_\+var)
\begin{DoxyCompactList}\small\item\em Compute parity of word with a multiply. \end{DoxyCompactList}\item 
bool \hyperlink{BitOperations_8c_ac63a832fbfb6cb6ead061652cc5ff9d6}{is\+Even\+Parity} (uint64\+\_\+t const \+\_\+var)
\begin{DoxyCompactList}\small\item\em Compute parity of word with a multiply. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{BitOperations_8c_a242b4cdc0b8cdfd70d599a5d0a90e1ae}{reverse\+Bit\+Order\+Byte} (uint8\+\_\+t const \+\_\+var)
\begin{DoxyCompactList}\small\item\em Reverse the order of bits in a byte. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{BitOperations_8c_a0fa8743f9d90ab9f3d5aa5f6d85296b9}{reverse\+Bit\+Order} (uint32\+\_\+t const \+\_\+var)
\begin{DoxyCompactList}\small\item\em Reverse an N-\/bit quantity in parallel in 5 $\ast$ lg(\+N) operations. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{BitOperations_8c_a2f1e70109083749542e415d9a91f8d8b}{round\+Up\+To\+Power\+Of2} (uint32\+\_\+t const \+\_\+var)
\begin{DoxyCompactList}\small\item\em Round up to the next highest power of 2 by float casting. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Several bit operations and manipulations, also known as \textquotesingle{}bit hacks\textquotesingle{}. 



\subsection{Function Documentation}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!bit\+Get@{bit\+Get}}
\index{bit\+Get@{bit\+Get}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{bit\+Get(uint64\+\_\+t \+\_\+var, uint8\+\_\+t \+\_\+n)}{bitGet(uint64_t _var, uint8_t _n)}}]{\setlength{\rightskip}{0pt plus 5cm}bool bit\+Get (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{\+\_\+var, }
\item[{uint8\+\_\+t}]{\+\_\+n}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_aceacd30a5f69a402340dce032e9a7ca2}{}\label{BitOperations_8c_aceacd30a5f69a402340dce032e9a7ca2}


Get the value of a single bit. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+var} & Variable to get a from. \\
\hline
{\em \+\_\+n} & Number of the bit to get where 0 is the rightmost bit \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if the selected bit was set, false else. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!bit\+Getm@{bit\+Getm}}
\index{bit\+Getm@{bit\+Getm}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{bit\+Getm(uint64\+\_\+t \+\_\+var, uint64\+\_\+t \+\_\+mask)}{bitGetm(uint64_t _var, uint64_t _mask)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t bit\+Getm (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{\+\_\+v, }
\item[{uint64\+\_\+t}]{\+\_\+mask}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_a82ec79150db7a149f761dba0c00341ad}{}\label{BitOperations_8c_a82ec79150db7a149f761dba0c00341ad}


Get the value of a bit or bits according to a mask. 

\begin{DoxyNote}{Note}
This will for example return 7 when all bits in a byte were set and the mask for getting the bits was 7. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em \+\_\+v} & The variable to get the bit(s) from. \\
\hline
{\em \+\_\+mask} & Mask for getting the bit(s). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint64\+\_\+t Value of the bits of v that where set according to the mask. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!have\+Opposite\+Signs@{have\+Opposite\+Signs}}
\index{have\+Opposite\+Signs@{have\+Opposite\+Signs}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{have\+Opposite\+Signs(int32\+\_\+t const \+\_\+x, int32\+\_\+t const \+\_\+y)}{haveOppositeSigns(int32_t const _x, int32_t const _y)}}]{\setlength{\rightskip}{0pt plus 5cm}bool have\+Opposite\+Signs (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t const}]{\+\_\+x, }
\item[{int32\+\_\+t const}]{\+\_\+y}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_a5a16a55c4150b94d46a15bb4bdb16ab8}{}\label{BitOperations_8c_a5a16a55c4150b94d46a15bb4bdb16ab8}


Detect if two integers have opposite signs. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+x} & First variable of which the signs need to be compared. \\
\hline
{\em \+\_\+y} & Second variable of which the signs need to be compared. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if the variables have opposite signs, false else. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!is\+Even@{is\+Even}}
\index{is\+Even@{is\+Even}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{is\+Even(int64\+\_\+t const \+\_\+var)}{isEven(int64_t const _var)}}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Even (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t const}]{\+\_\+v}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_a0a9fd2264e67c57264360215712e8131}{}\label{BitOperations_8c_a0a9fd2264e67c57264360215712e8131}


Compute parity of a variable to see if it is even. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+v} & Variable of which to compute the parity \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if the variable is even, false else. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!is\+Even\+Parity@{is\+Even\+Parity}}
\index{is\+Even\+Parity@{is\+Even\+Parity}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{is\+Even\+Parity(uint64\+\_\+t const \+\_\+var)}{isEvenParity(uint64_t const _var)}}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Even\+Parity (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t const}]{\+\_\+var}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_ac63a832fbfb6cb6ead061652cc5ff9d6}{}\label{BitOperations_8c_ac63a832fbfb6cb6ead061652cc5ff9d6}


Compute parity of word with a multiply. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+var} & Variable of which to compute the parity. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if the nuber of bits set in \+\_\+var is even, false else. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!is\+Odd@{is\+Odd}}
\index{is\+Odd@{is\+Odd}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{is\+Odd(int64\+\_\+t const \+\_\+var)}{isOdd(int64_t const _var)}}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Odd (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t const}]{\+\_\+var}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_ab610bca7d4f1b073611fd55ed5ab074a}{}\label{BitOperations_8c_ab610bca7d4f1b073611fd55ed5ab074a}


Compute parity of a variable to see if it is odd. 

Use one A\+N\+D-\/operation to check whether the L\+SB (zeroth bit) is set. \index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!is\+Odd\+Parity@{is\+Odd\+Parity}}
\index{is\+Odd\+Parity@{is\+Odd\+Parity}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{is\+Odd\+Parity(uint64\+\_\+t const \+\_\+var)}{isOddParity(uint64_t const _var)}}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Odd\+Parity (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t const}]{\+\_\+var}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_afbf3c541fcc9a3a38f94df4c91ccf320}{}\label{BitOperations_8c_afbf3c541fcc9a3a38f94df4c91ccf320}


Compute parity of word with a multiply. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+var} & Variable of which to compute the parity. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if the nuber of bits set in \+\_\+v is odd, false else. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!is\+Positive@{is\+Positive}}
\index{is\+Positive@{is\+Positive}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{is\+Positive(int32\+\_\+t const \+\_\+var)}{isPositive(int32_t const _var)}}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Positive (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t const}]{\+\_\+var}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_a8498303fa2475f5c04212f1269ca2e38}{}\label{BitOperations_8c_a8498303fa2475f5c04212f1269ca2e38}


Compute the sign of an integer. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+var} & Variable of which to compute the sign \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean value of 1 (true) if the variable is positive, 0 else. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!is\+Power\+Of2@{is\+Power\+Of2}}
\index{is\+Power\+Of2@{is\+Power\+Of2}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{is\+Power\+Of2(uint64\+\_\+t const \+\_\+var)}{isPowerOf2(uint64_t const _var)}}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Power\+Of2 (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t const}]{\+\_\+var}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_ac5c1620193273b5d6bc97d18b5b94a33}{}\label{BitOperations_8c_ac5c1620193273b5d6bc97d18b5b94a33}


Determining if an integer is a power of 2. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+var} & Variable of which to check if it is a power of two. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if \+\_\+v is a power of to, false else. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!max@{max}}
\index{max@{max}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{max(int32\+\_\+t const \+\_\+x, int32\+\_\+t const \+\_\+y)}{max(int32_t const _x, int32_t const _y)}}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t max (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t const}]{\+\_\+x, }
\item[{int32\+\_\+t const}]{\+\_\+y}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_a98b24b67752cb7a65d0bf14efd403a72}{}\label{BitOperations_8c_a98b24b67752cb7a65d0bf14efd403a72}


Compute the maximum of two integers without branching. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+x} & First variable of which the maximum needs to be found. \\
\hline
{\em \+\_\+y} & Second variable of which the maximum needs to be found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int32\+\_\+t The maximum value \+\_\+x or \+\_\+y. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!merge\+Bits@{merge\+Bits}}
\index{merge\+Bits@{merge\+Bits}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{merge\+Bits(uint32\+\_\+t const \+\_\+x, uint32\+\_\+t const \+\_\+y, uint32\+\_\+t const \+\_\+mask)}{mergeBits(uint32_t const _x, uint32_t const _y, uint32_t const _mask)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t merge\+Bits (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t const}]{\+\_\+x, }
\item[{uint32\+\_\+t const}]{\+\_\+y, }
\item[{uint32\+\_\+t const}]{\+\_\+mask}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_ac10caf47473a5d1c6b3cfd6808d61d9e}{}\label{BitOperations_8c_ac10caf47473a5d1c6b3cfd6808d61d9e}


Merge bits from two values according to a mask. 

\begin{DoxyNote}{Note}
This does not change the variable! 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em \+\_\+x} & Variable to merge in non-\/masked bits. \\
\hline
{\em \+\_\+y} & Variable to merge in masked bits. \\
\hline
{\em \+\_\+mask} & Bit mask for setting or clearing bits. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint32\+\_\+t Result of the merged variables \+\_\+x and \+\_\+y. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!min@{min}}
\index{min@{min}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{min(int32\+\_\+t const \+\_\+x, int32\+\_\+t const \+\_\+y)}{min(int32_t const _x, int32_t const _y)}}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t min (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t const}]{\+\_\+x, }
\item[{int32\+\_\+t const}]{\+\_\+y}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_a2a80e0c1b11281eedafad0691563e986}{}\label{BitOperations_8c_a2a80e0c1b11281eedafad0691563e986}


Compute the minimum of two integers without branching. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+x} & First variable of which the minimum needs to be found. \\
\hline
{\em \+\_\+y} & Second variable of which the minimum needs to be found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int32\+\_\+t The minimum value \+\_\+x or \+\_\+y. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!modify\+Bits@{modify\+Bits}}
\index{modify\+Bits@{modify\+Bits}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{modify\+Bits(uint32\+\_\+t $\ast$const \+\_\+var, uint32\+\_\+t const \+\_\+mask, bool const \+\_\+f)}{modifyBits(uint32_t *const _var, uint32_t const _mask, bool const _f)}}]{\setlength{\rightskip}{0pt plus 5cm}void modify\+Bits (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t $\ast$const}]{\+\_\+var, }
\item[{uint32\+\_\+t const}]{\+\_\+mask, }
\item[{bool const}]{\+\_\+f}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_a6c611cfb3747d5d8adb868840060c1bc}{}\label{BitOperations_8c_a6c611cfb3747d5d8adb868840060c1bc}


Conditionally set or clear bits without branching. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+var} & Pointer to the variable of which to set or clear bits. \\
\hline
{\em \+\_\+mask} & Bit mask for setting or clearing bits. \\
\hline
{\em \+\_\+f} & Flag whether the flag needs to be set or cleared (1 or 0). \\
\hline
\end{DoxyParams}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!n\+Bits\+Set@{n\+Bits\+Set}}
\index{n\+Bits\+Set@{n\+Bits\+Set}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{n\+Bits\+Set(uint32\+\_\+t const \+\_\+var)}{nBitsSet(uint32_t const _var)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t n\+Bits\+Set (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t const}]{\+\_\+var}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_a6c1510fc2d41e804ab05585b66cc59cd}{}\label{BitOperations_8c_a6c1510fc2d41e804ab05585b66cc59cd}


Counting bits set. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+var} & Variable of which to check how much bits are set. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint8\+\_\+t Number of bits set in \+\_\+var. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!reverse\+Bit\+Order@{reverse\+Bit\+Order}}
\index{reverse\+Bit\+Order@{reverse\+Bit\+Order}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{reverse\+Bit\+Order(uint32\+\_\+t const \+\_\+var)}{reverseBitOrder(uint32_t const _var)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t reverse\+Bit\+Order (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t const}]{\+\_\+var}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_a0fa8743f9d90ab9f3d5aa5f6d85296b9}{}\label{BitOperations_8c_a0fa8743f9d90ab9f3d5aa5f6d85296b9}


Reverse an N-\/bit quantity in parallel in 5 $\ast$ lg(\+N) operations. 

\begin{DoxyNote}{Note}
Now set to reverse the bit order of an 32 bit unsigned integer. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em \+\_\+var} & Variable of which the bit order needs to be reversed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint32\+\_\+t The reversed variable. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!reverse\+Bit\+Order\+Byte@{reverse\+Bit\+Order\+Byte}}
\index{reverse\+Bit\+Order\+Byte@{reverse\+Bit\+Order\+Byte}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{reverse\+Bit\+Order\+Byte(uint8\+\_\+t const \+\_\+var)}{reverseBitOrderByte(uint8_t const _var)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t reverse\+Bit\+Order\+Byte (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t const}]{\+\_\+var}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_a242b4cdc0b8cdfd70d599a5d0a90e1ae}{}\label{BitOperations_8c_a242b4cdc0b8cdfd70d599a5d0a90e1ae}


Reverse the order of bits in a byte. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+var} & Variable which needs to be reversed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint8\+\_\+t The reversed variable. 
\end{DoxyReturn}
\index{Bit\+Operations.\+c@{Bit\+Operations.\+c}!round\+Up\+To\+Power\+Of2@{round\+Up\+To\+Power\+Of2}}
\index{round\+Up\+To\+Power\+Of2@{round\+Up\+To\+Power\+Of2}!Bit\+Operations.\+c@{Bit\+Operations.\+c}}
\subsubsection[{\texorpdfstring{round\+Up\+To\+Power\+Of2(uint32\+\_\+t const \+\_\+var)}{roundUpToPowerOf2(uint32_t const _var)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t round\+Up\+To\+Power\+Of2 (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t const}]{\+\_\+var}
\end{DoxyParamCaption}
)}\hypertarget{BitOperations_8c_a2f1e70109083749542e415d9a91f8d8b}{}\label{BitOperations_8c_a2f1e70109083749542e415d9a91f8d8b}


Round up to the next highest power of 2 by float casting. 

\begin{DoxyNote}{Note}
This does not change the variable! 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em \+\_\+var} & Variable of which needs to be rounded up to the next highest power of 2. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint32\+\_\+t The next highest power of 2. 
\end{DoxyReturn}
